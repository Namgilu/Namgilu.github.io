<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PUBG Peeking Practice</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --accent-color: #f0a500;
            --success-color: #4caf50;
            --fail-color: #f44336;
            --cover-color: #555;
            --player-color: #fff;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        .layout-wrapper {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-direction: column;
            width: 80%;
            max-width: 1600px;
            /* Optional max-width */
            margin: 20px auto;
        }

        .top-row {
            display: flex;
            gap: 20px;
            width: 100%;
            justify-content: center;
        }



        /* Thumb */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
        }

        /* Disabled 상태 */
        input[type="range"]:disabled {
            background: #333;
            opacity: 0.4;
            cursor: not-allowed;
        }

        input[type="range"]:disabled::-webkit-slider-thumb {
            background: #666;
            cursor: not-allowed;
        }


        #game-container {
            position: relative;
            /* Width handled by flex */
            height: 480px;
            /* Increased height for log space */
            background-color: #252525;
            border: 1px solid #444;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: stretch;
            overflow: hidden;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            flex: 2;
            /* Game is 2x wider than side panels */
        }

        .game-header {
            padding: 10px;
            font-size: 1.1rem;
            color: #ddd;
            border-bottom: 1px solid #444;
            background: #252525;
            z-index: 10;
        }

        /* 3D-like Perspective */
        .scene {
            position: relative;
            width: 100%;
            flex: 1;
            /* Fill remaining height */
            perspective: 800px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 0;
            background: #222;
            /* Scene background */
        }

        #cover {
            position: absolute;
            width: 150px;
            height: 110px;
            background-color: var(--cover-color);
            z-index: 2;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            color: rgba(255, 255, 255, 0.2);
            font-weight: bold;
            font-size: 1.2rem;
            bottom: 200px;
            /* Align bottom */
        }

        #player {
            position: absolute;
            width: 60px;
            height: 140px;
            background-color: var(--player-color);
            z-index: 3;
            /* Behind cover initially */
            transition: transform 0.05s linear, background-color 0.1s;
            border-radius: 5px;
            border-radius: 5px;
            /* Center behind cover */
            bottom: 200px;
            /* Align bottom */
            transform-origin: bottom center;
        }

        /* Visual States */
        #player.leaning-left {
            transform: translateX(-60px) rotateZ(-15deg);
        }

        #player.leaning-right {
            transform: translateX(60px) rotateZ(15deg);
        }

        #player.crouching {
            height: 90px;
            /* top: 50% removed for bottom alignment */
        }

        #feedback-overlay {
            position: absolute;
            top: 100px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 1.8rem;
            font-weight: bold;
            text-transform: uppercase;
            pointer-events: none;
            z-index: 20;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.9);
            min-height: 2.5rem;
        }

        .msg-success {
            color: var(--success-color);
        }

        .msg-fail {
            color: var(--fail-color);
        }

        /* Stats Panel - Moved to Top Left */
        /* Stats Panel - Side */
        #stats-panel,
        #instructions-panel {
            width: 250px;
            background: #252525;
            padding: 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            border: 1px solid #444;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            box-sizing: border-box;
            height: 480px;
            flex: 1;
            /* Responsive flex */
            max-width: 300px;
            /* Limit width */
        }

        /* Log Panel - Side Right */
        #log-panel {
            /* flex: 1; removed */
            /* Height and position changed */
            width: 100%;
            height: 130px;
            /* Fixed height ~3 lines + header */
            background: #252525;
            border: 1px solid #444;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            color: #ddd;
            font-size: 0.85rem;
            box-sizing: border-box;
            border-radius: 8px;
        }


        #log-panel h3 {
            margin: 0;
            padding: 10px;
            font-size: 1.1rem;
            color: #ddd;
            border-bottom: 1px solid #444;
            position: sticky;
            top: 0;
            background: #252525;
            /* For sticky header */
            z-index: 5;
        }

        .key-display {
            display: inline-block;
            padding: 5px 10px;
            margin: 2px;
            border: 1px solid #666;
            border-radius: 4px;
            background: #333;
            color: #888;
            font-weight: bold;
            min-width: 1.2rem;
            text-align: center;
        }

        .key-display.active {
            background: var(--accent-color);
            color: #000;
            border-color: var(--accent-color);
            transform: translateY(2px);
        }

        /* Input Range Styling */
        input[type="range"] {
            width: 200px;
            margin-top: 10px;
        }

        #last-action-log {
            flex-grow: 1;
            padding: 10px;
            /* Added padding for content */
        }

        .log-entry {
            margin-bottom: 4px;
            border-bottom: 1px solid #444;
            padding-bottom: 2px;
            display: block;
        }

        .log-entry.error {
            color: #fe8888;
        }

        .log-entry.ok {
            color: #88fe88;
        }

        .debug-info {
            font-size: 0.75rem;
            color: #aaa;
            margin-top: 2px;
            font-family: monospace;
            margin-left: 10px;
        }

        /* Instructions Panel - Bottom */
        #instructions {
            width: 100%;
            /* Will adapt to flex container in top-row */
            background: #252525;
            padding: 10px;
            /* Reduced from 20px */
            border-radius: 8px;
            font-size: 0.9rem;
            border: 1px solid #444;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            height: 480px;
            max-width: 300px;
            /* Side panel limit */
            flex: 1;
            overflow-y: auto;
        }
    </style>
</head>

<body>

    <div class="layout-wrapper">
        <div class="top-row">
            <div id="stats-panel">
                <div
                    style="margin: -15px -15px 15px -15px; padding: 10px; font-size: 1.1rem; border-bottom: 1px solid #444; background: #252525; color: #ddd; border-radius: 8px 8px 0 0;">
                    <strong>통계 (STATISTICS)</strong>
                </div>
                <!-- ... Stats content ... -->
                <div style="display: flex; justify-content: space-between; margin-bottom: 15px;">
                    <span>SUCCESS: <span id="success-count"
                            style="color:var(--success-color); font-weight:bold;">0</span></span>
                    <span>FAIL: <span id="fail-count" style="color:var(--fail-color); font-weight:bold;">0</span></span>
                </div>

                <div style="margin-top:10px;"><strong>입력 상태 (INPUT)</strong></div>
                <div id="keys-container" style="background: rgba(255,255,255,0.05); padding: 5px; border-radius: 4px;">
                    <div style="display: flex; justify-content: center;">
                        <span class="key-display" id="key-q">Q</span>
                        <span class="key-display" id="key-w">W</span>
                        <span class="key-display" id="key-e">E</span>
                    </div>
                    <div style="display: flex; justify-content: center;">
                        <span class="key-display" id="key-a">A</span>
                        <span class="key-display" id="key-s">S</span>
                        <span class="key-display" id="key-d">D</span>
                    </div>
                    <div style="display: flex; justify-content: center; margin-top: 4px;">
                        <span class="key-display" id="key-c" style="width: 80px;">C</span>
                        <span class="key-display" id="key-space" style="width: 80px;">SPACE</span>
                    </div>
                </div>

                <div style="margin-top:10px; border-top: 1px solid #555; padding-top: 10px;">
                    <label style="display:flex; justify-content:space-between; align-items:center;">
                        <span>
                            <input type="checkbox" id="interval-check-toggle">
                            입력 리듬 체크
                        </span>
                        <span style="color:#aaa; font-size:0.8rem;">
                            Q/A/C 간격
                        </span>
                    </label>
                </div>
                <div style="margin-top:15px; border-top: 1px solid #555; padding-top: 10px;">
                    <label style="display:flex; justify-content:space-between; align-items:center;">
                        <span>
                            <input type="checkbox" id="server-delay-toggle">
                            Server Delay
                        </span>
                        <span style="color: var(--accent-color)">
                            <span id="delay-value">100</span>ms
                        </span>
                    </label>
                    <input type="range" id="delay-slider" min="30" max="200" step="10" value="100" disabled>
                </div>

                <div style="margin-top:10px; border-top: 1px solid #555; padding-top: 10px;">
                    <label for="max-window-slider" style="display: flex; justify-content: space-between;">
                        <span>Max Window</span>
                        <span style="color: var(--accent-color)"><span id="max-window-value">120</span>ms</span>
                    </label>
                    <input type="range" id="max-window-slider" min="100" max="200" step="1" value="120">
                </div>

                <div style="margin-top:10px; border-top: 1px solid #555; padding-top: 10px;">
                    <label for="stop-slider" style="display: flex; justify-content: space-between;">
                        <span>Ref. Stop Time</span>
                        <span style="color: var(--accent-color)"><span id="stop-value">0.20</span>s</span>
                    </label>
                    <input type="range" id="stop-slider" min="0" max="500" step="10" value="200">
                </div>
            </div>

            <div id="game-container">
                <div class="game-header"><strong>게임 화면 (SCENE)</strong></div>
                <div id="feedback-overlay"></div>

                <div class="scene">
                    <div id="cover">담장</div>
                    <div id="player"></div>
                </div>
            </div>

            <div id="instructions-panel">
                <div
                    style="margin: -15px -15px 15px -15px; padding: 10px; font-size: 1.1rem; border-bottom: 1px solid #444; background: #252525; color: #ddd; border-radius: 8px 8px 0 0;">
                    <strong>연습 방법 (How to)</strong>
                </div>
                <div style="display: flex; flex-direction: column; gap: 20px;">
                    <!-- Method -->
                    <div>
                        <ul style="padding-left: 20px; margin: 0; color: #ddd; line-height: 1.6; font-size: 0.85rem;">
                            <li style="margin-bottom: 8px;">
                                <strong>기본 루트 (정석)</strong><br>
                                <span style="color:#aaa;">Q-A-C (나가기) ➔ 0.1초내 사격 ➔ E-D-C (복귀)</span>
                            </li>
                            <li>
                                <strong>보조 루트 (피킹 생략)</strong><br>
                                <span style="color:#aaa;">A-C ➔ 발사 ➔ E-D-C</span>
                                <div style="font-size: 0.75rem; color: #fe8; margin-top: 2px;">
                                    * 실전에서 이미 각이 열린 상황을 가정한 연습용.<br>
                                    * 기본 연습은 QAC 루트를 권장합니다.
                                </div>
                            </li>
                        </ul>
                    </div>

                    <!-- Left: Method Details -->
                    <div
                        style="margin-top:0; padding-top:0; border-top: 1px solid #444; font-size: 0.8rem; color: #888;">
                        <br>
                        * <b>성공 조건</b>: C 입력 후 90ms~MaxWindow 내 발사. <br>
                        * <b>좌각</b>: QAC (또는 AC) ➔ 사격 ➔ EDC <br>
                        * 반드시 복귀(EDC)까지 완료해야 점수가 오릅니다.
                    </div>

                    <!-- Settings -->
                    <div style="padding-top: 10px; border-top: 1px solid #444;">
                        <h4 style="margin: 0 0 5px 0; color: #aaa; font-size: 0.9rem;">설정</h4>
                        <ul style="padding-left: 20px; margin: 0; color: #ccc; font-size: 0.8rem; line-height: 1.4;">
                            <li><strong>리듬 체크</strong>: Q/A/C 간격 검사.</li>
                            <li><strong>Delay</strong>: 핑 시뮬레이션.</li>
                            <li><strong>Window</strong>: 유효 타격 시간.</li>
                            <li><strong>Stop Time</strong>: 정지 타이밍 (참고).</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <div id="log-panel">
            <h3>판정 로그 (LOGS)</h3>
            <div id="last-action-log">Wait for input...</div>
        </div>
    </div>

    <div style="position: fixed; bottom: 10px; left: 10px; color: #666; font-size: 0.8rem; z-index: 10;">
        © 2026 gwNam.
        Licensed under the
        <a href="https://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener noreferrer">
            Apache License, Version 2.0
        </a>.
    </div>

    <script>
        // --- Configuration ---
        const PEEK_CONFIG = {
            MIN_INTERVAL: 80,    // ms
            MAX_INTERVAL: 300,   // ms
            // STOP_REQ is now dynamic
        };

        // --- State ---
        let serverDelay = 100;
        let maxHitWindow = 120; // ms (Max Hit Window)
        let stopReq = 200; // ms (Ref Stop Time)
        let stats = { success: 0, fail: 0 };

        // Input History
        // Format: { key: string, time: number, type: 'down'|'up' }
        const inputLog = [];
        const MAX_HISTORY = 50;

        // Current Active Keys (for visuals & logic)
        const activeKeys = new Set();

        // Movement State Tracking
        let lastMovementReleaseTime = 0; // When A/D were last FULLY released
        let lastStanceChangeTime = 0;    // When C was last pressed (Stand OR Crouch)
        let isCrouching = true;          // Start Crouched (as per prompt implication for "Standing up to shoot")
        let isMoving = false; // A or D held
        let serverDelayEnabled = false;
        let enableInputIntervalCheck = false; // 기본 ON (교정 모드)

        function now() { return performance.now(); }

        // --- Elements ---
        const playerEl = document.getElementById('player');
        const feedbackEl = document.getElementById('feedback-overlay');
        const successCountEl = document.getElementById('success-count');
        const failCountEl = document.getElementById('fail-count');
        const actionLogEl = document.getElementById('last-action-log');

        const delaySlider = document.getElementById('delay-slider');
        const delayValEl = document.getElementById('delay-value');

        const maxWindowSlider = document.getElementById('max-window-slider');
        const maxWindowValEl = document.getElementById('max-window-value');

        const stopSlider = document.getElementById('stop-slider');
        const stopValEl = document.getElementById('stop-value');

        const keyEls = {
            'q': document.getElementById('key-q'),
            'w': document.getElementById('key-w'),
            'e': document.getElementById('key-e'),
            'a': document.getElementById('key-a'),
            's': document.getElementById('key-s'), // Included for layout consistency
            'd': document.getElementById('key-d'),
            'c': document.getElementById('key-c'),
            ' ': document.getElementById('key-space')  // Changed to ' ' key
        };

        // --- UI Updates ---
        delaySlider.addEventListener('input', (e) => {
            serverDelay = parseInt(e.target.value);
            delayValEl.innerText = serverDelay;
        });

        maxWindowSlider.addEventListener('input', (e) => {
            maxHitWindow = parseInt(e.target.value);
            maxWindowValEl.innerText = maxHitWindow;
        });

        stopSlider.addEventListener('input', (e) => {
            stopReq = parseInt(e.target.value);
            stopValEl.innerText = (stopReq / 1000).toFixed(2);
        });

        const serverDelayToggle = document.getElementById('server-delay-toggle');

        serverDelayToggle.addEventListener('change', (e) => {
            serverDelayEnabled = e.target.checked;

            delaySlider.disabled = !serverDelayEnabled;
            delaySlider.style.opacity = serverDelayEnabled ? '1.0' : '0.4';
        });

        const intervalToggle = document.getElementById('interval-check-toggle');

        intervalToggle.addEventListener('change', (e) => {
            enableInputIntervalCheck = e.target.checked;
        });


        function updateVisuals() {
            // Update Key Highlights
            for (const k in keyEls) {
                let isActive = activeKeys.has(k);

                // For Crouch (C), use the toggle state
                if (k === 'c') {
                    isActive = isCrouching;
                }

                if (isActive) keyEls[k].classList.add('active');
                else keyEls[k].classList.remove('active');
            }

            // Client Visuals - Immediate Response
            let transform = '';
            let height = 140; /* Default Standing Height */

            // Note: Visual height change logic
            // In PUBG, C toggles, but here we track holding or simple state.
            // Prompt implies user PRESSES C as part of combo.
            if (isCrouching) {
                height = 90;
                transform += 'translateY(0px) '; // Visually lower
            }

            // Movement / Lean Logic
            const leanLeft = activeKeys.has('q');
            const leanRight = activeKeys.has('e');
            const moveLeft = activeKeys.has('a');
            const moveRight = activeKeys.has('d');

            let xOffset = 0;
            let rotate = 0;

            // Simple priority logic for visuals
            if (leanLeft) {
                xOffset = -70;
                rotate = -15;
            } else if (leanRight) {
                xOffset = 70;
                rotate = 15;
            } else if (moveLeft) {
                xOffset = -40;
            } else if (moveRight) {
                xOffset = 40;
            }

            if (rotate !== 0) {
                transform += `translateX(${xOffset}px) rotateZ(${rotate}deg) `;
            } else {
                transform += `translateX(${xOffset}px) `;
            }

            playerEl.style.height = height + 'px';
            playerEl.style.transform = transform;
        }

        // --- Input Handling ---
        // Map physical keys to logical actions
        const KEY_MAP = {
            'KeyQ': 'q',
            'KeyW': 'w',
            'KeyE': 'e',
            'KeyA': 'a',
            'KeyS': 's',
            'KeyD': 'd',
            'KeyC': 'c',
            'Space': ' ',
            'KeyF': 'f'
        };

        let pendingShot = null; // { type: 'EDC'|'QAC', fireTime: number, timer: number }

        window.addEventListener('keydown', (e) => {
            if (e.repeat) return;

            // Prevent scrolling for game keys
            if (KEY_MAP[e.code] || e.code === 'Space') {
                // Only prevent default if it's a game key to avoid blocking F12/Refresh etc if they clash, 
                // but Space definitely needs it.
                if (e.code === 'Space') e.preventDefault();
            }

            const code = e.code;
            let k = KEY_MAP[code];
            if (!k) return; // Ignore non-game keys

            // Fire Logic
            if (k === ' ' || k === 'f') {
                handleFire();
                activeKeys.add(' '); // Visual feedback
                setTimeout(() => activeKeys.delete(' '), 100);
                updateVisuals();
                return;
            }

            if (keyEls[k]) {
                activeKeys.add(k);
                const ts = now();
                inputLog.unshift({ key: k, time: ts, type: 'down' });
                if (inputLog.length > MAX_HISTORY) inputLog.pop();

                // State Updates
                if (k === 'c') {
                    const wasCrouching = isCrouching;
                    isCrouching = !isCrouching;

                    // ❗ 앉아있다가 → 섰을 때만 기준 시간 갱신
                    if (wasCrouching && !isCrouching) {
                        lastStanceChangeTime = ts;
                    }
                }
                // if (k === 'a' || k === 'd') {
                //     isMoving = true;
                // }

                updateVisuals();
                checkForReturnSequence(k); // Check for return sequence on every keydown
            }
        });

        window.addEventListener('keyup', (e) => {
            const code = e.code;
            let k = KEY_MAP[code];
            if (!k) return;

            if (k === ' ' || k === 'f') {
                activeKeys.delete(' ');
                updateVisuals();
                return;
            }

            if (keyEls[k]) {
                activeKeys.delete(k);
                const ts = now();
                inputLog.unshift({ key: k, time: ts, type: 'up' });
                if (inputLog.length > MAX_HISTORY) inputLog.pop();

                // State Updates
                // Note: C is now Toggle, so we don't change state on keyup

                if (k === 'a' || k === 'd') {
                    // Check if other movement key is still held
                    const moving = activeKeys.has('a') || activeKeys.has('d');
                    isMoving = moving;
                    if (!moving) {
                        lastMovementReleaseTime = ts;
                    }
                }
                updateVisuals();
            }
        });

        const sceneEl = document.querySelector('.scene');

        sceneEl.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return;

            handleFire();
        });

        // --- Core Logic ---

        function handleFire() {
            if (pendingShot) return; // Prevent double firing overlap logic

            const fireTime = now();

            // Capture state
            const stateSnapshot = {
                fireTime: fireTime,
                isCrouching: isCrouching,
                isMoving: isMoving,
                lastStop: lastMovementReleaseTime,
                lastStanceChange: lastStanceChangeTime,
                recentInputs: inputLog.slice(0, 20).map(i => ({ ...i })),
            };

            const preCheck = checkPreFireConditions(stateSnapshot);

            // Immediate Check (Simulated Delay comes later if successful)
            // Actually, we must delay the JUDGEMENT, but we can verify logic now.
            // If we delay logic, we can't track "future" inputs for post-fire easily without complex async.
            // Approach: 
            // 1. Validate Pre-Fire State immediately.
            // 2. If invalid -> Schedule Fail Feedback (delayed).
            // 3. If valid -> Start "Wait for Return" mode.
            // 4. In KeyDown, if Return completes -> Schedule Success Feedback (delayed from completion time).

            // DEFERRED FEEDBACK LOGIC
            // If invalid but TYPE is known (e.g. Too Fast/Slow), we wait for return.
            // If invalid and NO TYPE (e.g. just random clicking), fail immediately.
            const delay = serverDelayEnabled ? serverDelay : 0;

            if (!preCheck.valid && !preCheck.type) {
                setTimeout(() => {
                    showFeedback(false, preCheck.msg, preCheck.debug);
                }, delay);
                return;
            }
            // Valid OR Invalid-but-typed (Deferred)
            // If preCheck.type is QAC (e.g. started with QAC), return target is EDC.
            // Also supports auxiliary AC type.
            const targetType = (['QAC', 'AC'].includes(preCheck.type)) ? 'EDC' : 'QAC';

            pendingShot = {
                type: targetType,
                fireTime: fireTime,
                result: preCheck, // Store the judgement result
                timer: setTimeout(() => {
                    if (preCheck.valid) {
                        showFeedback(false, `${targetType} -> 발사 -> EDC 실패 (복귀 누락)`, "Missing Return Sequence");
                    } else {
                        showFeedback(false, preCheck.msg, preCheck.debug);
                    }
                    pendingShot = null;
                }, 1200 + (serverDelayEnabled ? serverDelay : 0))

                // We mimic "Server Logic" by just holding this state. 
                // Real inputs will clear it.
            }

            // Check if Pre-Fire execution (EDC->Fire) was good
            function checkPreFireConditions(state) {
                const T_FIRE = state.fireTime;

                // 1. Pattern Detection (First Priority)
                // Find Stand-Up (C Down)
                const cIdx = state.recentInputs.findIndex(i => i.key === 'c' && i.type === 'down' && i.time <= T_FIRE);
                if (cIdx === -1) return { valid: false, msg: "C 입력 없음", debug: "No C found" }; // Immediate Fail

                // Find Move
                let mIdx = -1, mKey = '';
                for (let i = cIdx + 1; i < state.recentInputs.length; i++) {
                    if (state.recentInputs[i].type === 'down' && ['a', 'd'].includes(state.recentInputs[i].key)) {
                        mIdx = i; mKey = state.recentInputs[i].key; break;
                    }
                }
                if (mIdx === -1) return { valid: false, msg: "[Unknown] -> 이동 입력 누락", debug: "No A/D before C" };


                // Find Peek (Optional for Auxiliary Route)
                let pIdx = -1, pKey = '';
                const expectedPeek = (mKey === 'a') ? 'q' : 'e';
                for (let i = mIdx + 1; i < state.recentInputs.length; i++) {
                    const evt = state.recentInputs[i];

                    // Stop searching if we hit a 'sequence breaker' (C or Fire or another Move?)
                    // If we see 'c' (down) or ' ' (down) or 'f' (down), this likely belongs to previous action.
                    if (evt.type === 'down' && ['c', ' ', 'f'].includes(evt.key)) {
                        break;
                    }

                    if (evt.type === 'down' && ['q', 'e'].includes(evt.key)) {
                        pIdx = i; pKey = evt.key; break;
                    }
                }

                // Determine Type
                let type = '';
                let isAuxiliary = false;

                if (pIdx !== -1) {
                    // Standard QAC / EDC
                    type = (expectedPeek === 'q') ? 'QAC' : 'EDC';

                    // Combination Check
                    if (pKey !== expectedPeek) {
                        return { valid: false, type: type, msg: `${type} -> 조합 오류 (${pKey}+${mKey})`, debug: `${pKey}+${mKey} (Expected ${expectedPeek})` };
                    }
                } else {
                    // Auxiliary AC / DC
                    isAuxiliary = true;
                    type = (mKey === 'a') ? 'AC' : 'DC';
                    // No peek key to check
                }

                // Timing Check
                const timeSinceStanceChange = T_FIRE - state.lastStanceChange;
                const delta = Math.round(timeSinceStanceChange);

                if (delta < 90) {
                    return {
                        valid: false,
                        type: type,
                        msg: `${type} -> 타이밍 빠름 (<90ms)`,
                        debug: `Too Fast (${delta}ms) < 90ms`
                    };
                }

                if (delta > maxHitWindow) {
                    return {
                        valid: false,
                        type: type,
                        msg: `${type} -> 타이밍 늦음 (>${maxHitWindow}ms)`,
                        debug: `Too Slow (${delta}ms) > ${maxHitWindow}ms`
                    };
                }

                // Input Interval Check
                const cEvent = state.recentInputs[cIdx];
                const mEvent = state.recentInputs[mIdx];
                // pEvent only exists for Standard type

                let intervalsOk = true;
                let debugIntervals = "";

                if (enableInputIntervalCheck) {
                    const d2 = cEvent.time - mEvent.time; // Move -> Crouch

                    if (d2 < PEEK_CONFIG.MIN_INTERVAL) {
                        intervalsOk = false;
                        debugIntervals = `M->C: ${Math.round(d2)}ms`;
                    }

                    if (!isAuxiliary) {
                        const pEvent = state.recentInputs[pIdx];
                        const d1 = mEvent.time - pEvent.time; // Peek -> Move
                        if (d1 < PEEK_CONFIG.MIN_INTERVAL) {
                            intervalsOk = false;
                            debugIntervals += (debugIntervals ? ", " : "") + `P->M: ${Math.round(d1)}ms`;
                        }
                    }

                    if (!intervalsOk) {
                        return {
                            valid: false,
                            type: type,
                            msg: `${type} -> 입력 간격 위반`,
                            debug: `Intervals: ${debugIntervals}`
                        };
                    }
                }

                // Success
                if (isAuxiliary) {
                    successMsg = `${type} -> 발사 -> EDC 성공 (${delta}ms)`;
                } else {
                    successMsg = `${type} -> 발사 -> EDC 성공 (${delta}ms)`;
                }

                return {
                    valid: true,
                    type: type,
                    msg: successMsg,
                    debug: `PERFECT TIMING (${delta}ms)\n${type} Route`
                };
            }
        }

        function checkForReturnSequence(key) {
            if (!pendingShot) return;

            // Strict Sequence Check for Return
            // Target: EDC -> E, D, C (in that order)
            // We check the last 3 'down' events since fire.

            // Get inputs since fire
            const recent = inputLog.filter(i => i.time > pendingShot.fireTime && i.type === 'down');

            // If we have fewer than 3 inputs, we can't have completed EDC yet.
            if (recent.length < 3) return;

            // `recent` array is ordered Newest to Oldest (index 0 is newest).
            // We want [Oldest, Middle, Newest] to be [E, D, C].

            const lastKey = recent[0];  // Newest (should be C)
            const prevKey = recent[1];  // Middle (should be D)
            const firstKey = recent[2]; // Oldest (should be E)

            // 1. Trigger Check: Must be the 'c' key press that finishes it.
            if (key !== 'c') return;
            if (lastKey.key !== 'c') return; // Double check history

            let matched = false;

            if (pendingShot.type === 'EDC') {
                // Expect E -> D -> C
                if (firstKey.key === 'e' && prevKey.key === 'd' && lastKey.key === 'c') matched = true;
            } else {
                // Expect Q -> A -> C (if hypothetical Right Peek started)
                if (firstKey.key === 'q' && prevKey.key === 'a' && lastKey.key === 'c') matched = true;
            }

            if (matched) {
                // Success (or Resolved Failure)
                clearTimeout(pendingShot.timer);

                // Use stored result
                const isSuccess = pendingShot.result.valid;
                const msg = pendingShot.result.msg || `서버 판정 프레임 명중 (90~${maxHitWindow}ms)`;
                const debug = pendingShot.result.debug + `\nReturn: ${pendingShot.type} OK`;

                const delayWait = serverDelayEnabled ? serverDelay : 0;

                setTimeout(() => {
                    showFeedback(isSuccess, msg, debug);
                }, delayWait);

                pendingShot = null;
            }
        }

        let feedbackTimer = null;

        function showFeedback(isSuccess, msg, debugInfo = "") {
            // Stats
            if (isSuccess) stats.success++;
            else stats.fail++;

            successCountEl.innerText = stats.success;
            failCountEl.innerText = stats.fail;

            // UI
            feedbackEl.innerText = msg;
            feedbackEl.className = isSuccess ? 'msg-success' : 'msg-fail';

            // Log
            actionLogEl.innerHTML = `<div class="log-entry ${isSuccess ? 'ok' : 'error'}">` +
                `<div>${msg}</div><div class="debug-info">${debugInfo}</div></div>` +
                actionLogEl.innerHTML.slice(0, 1000); // Truncate history

            // Visual Tint
            playerEl.style.backgroundColor = isSuccess
                ? getComputedStyle(document.documentElement).getPropertyValue('--success-color')
                : getComputedStyle(document.documentElement).getPropertyValue('--fail-color');

            if (feedbackTimer) clearTimeout(feedbackTimer);

            feedbackTimer = setTimeout(() => {
                playerEl.style.backgroundColor = ""; // Reset
                feedbackTimer = null;
            }, 1500);
        }

        // Initialize Visuals
        updateVisuals();
    </script>
</body>

</html>
