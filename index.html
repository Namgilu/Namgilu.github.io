<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PUBG Peeking Practice (EDC/QAC)</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --accent-color: #f0a500;
            --success-color: #4caf50;
            --fail-color: #f44336;
            --cover-color: #555;
            --player-color: #fff;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        .layout-wrapper {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        #game-container {
            position: relative;
            width: 600px;
            height: 600px;
            /* Increased height for log space */
            background-color: #252525;
            border: 2px solid #444;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        /* 3D-like Perspective */
        .scene {
            position: relative;
            width: 100%;
            height: 100%;
            perspective: 800px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 0;
        }

        #cover {
            position: absolute;
            width: 150px;
            height: 110px;
            background-color: var(--cover-color);
            z-index: 2;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            color: rgba(255, 255, 255, 0.2);
            font-weight: bold;
            font-size: 1.2rem;
            bottom: 250px;
            /* Align bottom */
        }

        #player {
            position: absolute;
            width: 60px;
            height: 140px;
            background-color: var(--player-color);
            z-index: 3;
            /* Behind cover initially */
            transition: transform 0.05s linear, background-color 0.1s;
            border-radius: 5px;
            border-radius: 5px;
            /* Center behind cover */
            bottom: 250px;
            /* Align bottom */
            transform-origin: bottom center;
        }

        /* Visual States */
        #player.leaning-left {
            transform: translateX(-60px) rotateZ(-15deg);
        }

        #player.leaning-right {
            transform: translateX(60px) rotateZ(15deg);
        }

        #player.crouching {
            height: 90px;
            /* top: 50% removed for bottom alignment */
        }

        #feedback-overlay {
            position: absolute;
            top: 100px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 1.8rem;
            font-weight: bold;
            text-transform: uppercase;
            pointer-events: none;
            z-index: 20;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.9);
            min-height: 2.5rem;
        }

        .msg-success {
            color: var(--success-color);
        }

        .msg-fail {
            color: var(--fail-color);
        }

        /* Stats Panel - Moved to Top Left */
        /* Stats Panel - Side */
        #stats-panel {
            width: 250px;
            background: #252525;
            padding: 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            border: 1px solid #444;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            box-sizing: border-box;
            height: fit-content;
        }

        /* Log Panel - Bottom Full Width */
        #log-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 150px;
            background: rgba(0, 0, 0, 0.85);
            border-top: 1px solid #555;
            padding: 10px;
            box-sizing: border-box;
            z-index: 10;
            overflow-y: auto;
            color: #ddd;
            font-size: 0.85rem;
            display: flex;
            flex-direction: column;
        }

        #log-panel h3 {
            margin: 0 0 5px 0;
            font-size: 0.9rem;
            color: #aaa;
            border-bottom: 1px solid #444;
            padding-bottom: 2px;
            position: sticky;
            top: 0;
            background: rgba(0, 0, 0, 0.85);
            /* For sticky header */
        }

        .key-display {
            display: inline-block;
            padding: 5px 10px;
            margin: 2px;
            border: 1px solid #666;
            border-radius: 4px;
            background: #333;
            color: #888;
            font-weight: bold;
            min-width: 1.2rem;
            text-align: center;
        }

        .key-display.active {
            background: var(--accent-color);
            color: #000;
            border-color: var(--accent-color);
            transform: translateY(2px);
        }

        /* Input Range Styling */
        input[type="range"] {
            width: 200px;
            margin-top: 10px;
        }

        #last-action-log {
            flex-grow: 1;
        }

        .log-entry {
            margin-bottom: 4px;
            border-bottom: 1px solid #444;
            padding-bottom: 2px;
            display: block;
        }

        .log-entry.error {
            color: #fe8888;
        }

        .log-entry.ok {
            color: #88fe88;
        }

        .debug-info {
            font-size: 0.75rem;
            color: #aaa;
            margin-top: 2px;
            font-family: monospace;
            margin-left: 10px;
        }

        /* Instructions Panel - Side */
        #instructions {
            width: 250px;
            background: #252525;
            padding: 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            border: 1px solid #444;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            /* Height match game container roughly or auto */
            max-height: 600px;
            overflow-y: auto;
        }
    </style>
</head>

<body>

    <div class="layout-wrapper">
        <div id="stats-panel">
            <div style="margin-bottom: 10px; font-size: 1.1rem; border-bottom: 1px solid #555; padding-bottom: 5px;">
                <strong>STATISTICS</strong>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 15px;">
                <span>SUCCESS: <span id="success-count"
                        style="color:var(--success-color); font-weight:bold;">0</span></span>
                <span>FAIL: <span id="fail-count" style="color:var(--fail-color); font-weight:bold;">0</span></span>
            </div>

            <div style="margin-top:10px;"><strong>INPUT STATE</strong></div>
            <div id="keys-container" style="background: rgba(255,255,255,0.05); padding: 5px; border-radius: 4px;">
                <div style="display: flex; justify-content: center;">
                    <span class="key-display" id="key-q">Q</span>
                    <span class="key-display" id="key-w">W</span>
                    <span class="key-display" id="key-e">E</span>
                </div>
                <div style="display: flex; justify-content: center;">
                    <span class="key-display" id="key-a">A</span>
                    <span class="key-display" id="key-s">S</span>
                    <span class="key-display" id="key-d">D</span>
                </div>
                <div style="display: flex; justify-content: center; margin-top: 4px;">
                    <span class="key-display" id="key-c" style="width: 80px;">C</span>
                    <span class="key-display" id="key-space" style="width: 80px;">SPACE</span>
                </div>
            </div>

            <div style="margin-top:15px; border-top: 1px solid #555; padding-top: 10px;">
                <label for="delay-slider" style="display: flex; justify-content: space-between;">
                    <span>Server Delay</span>
                    <span style="color: var(--accent-color)"><span id="delay-value">100</span>ms</span>
                </label>
                <input type="range" id="delay-slider" min="0" max="300" value="100">
            </div>

            <div style="margin-top:10px; border-top: 1px solid #555; padding-top: 10px;">
                <label for="max-window-slider" style="display: flex; justify-content: space-between;">
                    <span>Max Window</span>
                    <span style="color: var(--accent-color)"><span id="max-window-value">120</span>ms</span>
                </label>
                <input type="range" id="max-window-slider" min="100" max="200" step="1" value="120">
            </div>

            <div style="margin-top:10px; border-top: 1px solid #555; padding-top: 10px;">
                <label for="stop-slider" style="display: flex; justify-content: space-between;">
                    <span>Ref. Stop Time</span>
                    <span style="color: var(--accent-color)"><span id="stop-value">0.20</span>s</span>
                </label>
                <input type="range" id="stop-slider" min="0" max="500" step="10" value="200">
            </div>
        </div>

        <div id="game-container">
            <div id="feedback-overlay"></div>



            <div id="log-panel">
                <h3>LAST JUDGEMENT LOG</h3>
                <div id="last-action-log">Wait for input...</div>
            </div>

            <div class="scene">
                <div id="cover">담장</div>
                <div id="player"></div>
            </div>
        </div>

        <div id="instructions">
            <h3 style="margin-top:0; color: var(--accent-color); border-bottom: 1px solid #444; padding-bottom: 10px;">
                연습 방법
                (COMBO)</h3>

            <div style="margin-bottom: 15px;">
                <div style="font-weight:bold; color: #fff; margin-bottom:4px;">성공 조건</div>
                <div style="color: #bbb;">QAC (나가기) ➔ 0.1초내 사격 ➔ EDC (복귀)</div>
            </div>

            <ul style="padding-left: 20px; margin: 0; color: #ddd; line-height: 1.6;">
                <li><strong>1단계</strong>: (EDC 상태에서) <b>Q</b>➔<b>A</b>➔<b>C</b> (나가기/서기)</li>
                <li><strong>2단계</strong>: C 직후 <b>0.1초 내</b> 발사. (90~120ms)</li>
                <li><strong>3단계</strong>: 즉시 <b>E</b>➔<b>D</b>➔<b>C</b>를 입력하여 복귀/앉기.</li>
            </ul>

            <div style="margin-top:15px; padding-top:10px; border-top: 1px solid #444; font-size: 0.8rem; color: #888;">
                * <b>좌각 (Left)</b>: (Q 옵션)-A-C ➔ 사격 ➔ E-D-C<br>
                * 복귀 동작까지 완료해야 점수가 오릅니다.
            </div>

            <div style="margin-top:20px; border-top: 1px solid #444; padding-top: 10px;">
                <h4 style="margin: 0 0 10px 0; color: #aaa;">설정 설명</h4>
                <ul style="padding-left: 20px; margin: 0; color: #ccc; font-size: 0.85rem; line-height: 1.5;">
                    <li><strong>Server Delay</strong>: 서버 응답 지연 (핑) 시뮬레이션. 판정 결과가 이 시간만큼 늦게 표시됩니다.</li>
                    <li><strong>Max Window</strong>: 유효 타격 시간 (기본 120ms). C 입력 후 이 시간 내에 발사해야 히트박스 이득이 인정됩니다.</li>
                    <li><strong>Ref. Stop Time</strong>: 이동 정지 후 발사까지의 권장 타이밍 (참고용). 로직에는 영향을 주지 않습니다.</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const PEEK_CONFIG = {
            MIN_INTERVAL: 80,    // ms
            MAX_INTERVAL: 300,   // ms
            // STOP_REQ is now dynamic
        };

        // --- State ---
        let serverDelay = 100;
        let maxHitWindow = 120; // ms (Max Hit Window)
        let stopReq = 200; // ms (Ref Stop Time)
        let stats = { success: 0, fail: 0 };

        // Input History
        // Format: { key: string, time: number, type: 'down'|'up' }
        const inputLog = [];
        const MAX_HISTORY = 50;

        // Current Active Keys (for visuals & logic)
        const activeKeys = new Set();

        // Movement State Tracking
        let lastMovementReleaseTime = 0; // When A/D were last FULLY released
        let lastStanceChangeTime = 0;    // When C was last pressed (Stand OR Crouch)
        let isCrouching = true;          // Start Crouched (as per prompt implication for "Standing up to shoot")
        let isMoving = false; // A or D held

        function now() { return performance.now(); }

        // --- Elements ---
        const playerEl = document.getElementById('player');
        const feedbackEl = document.getElementById('feedback-overlay');
        const successCountEl = document.getElementById('success-count');
        const failCountEl = document.getElementById('fail-count');
        const actionLogEl = document.getElementById('last-action-log');

        const delaySlider = document.getElementById('delay-slider');
        const delayValEl = document.getElementById('delay-value');

        const maxWindowSlider = document.getElementById('max-window-slider');
        const maxWindowValEl = document.getElementById('max-window-value');

        const stopSlider = document.getElementById('stop-slider');
        const stopValEl = document.getElementById('stop-value');

        const keyEls = {
            'q': document.getElementById('key-q'),
            'w': document.getElementById('key-w'),
            'e': document.getElementById('key-e'),
            'a': document.getElementById('key-a'),
            's': document.getElementById('key-s'), // Included for layout consistency
            'd': document.getElementById('key-d'),
            'c': document.getElementById('key-c'),
            ' ': document.getElementById('key-space')  // Changed to ' ' key
        };

        // --- UI Updates ---
        delaySlider.addEventListener('input', (e) => {
            serverDelay = parseInt(e.target.value);
            delayValEl.innerText = serverDelay;
        });

        maxWindowSlider.addEventListener('input', (e) => {
            maxHitWindow = parseInt(e.target.value);
            maxWindowValEl.innerText = maxHitWindow;
        });

        stopSlider.addEventListener('input', (e) => {
            stopReq = parseInt(e.target.value);
            stopValEl.innerText = (stopReq / 1000).toFixed(2);
        });

        function updateVisuals() {
            // Update Key Highlights
            for (const k in keyEls) {
                let isActive = activeKeys.has(k);

                // For Crouch (C), use the toggle state
                if (k === 'c') {
                    isActive = isCrouching;
                }

                if (isActive) keyEls[k].classList.add('active');
                else keyEls[k].classList.remove('active');
            }

            // Client Visuals - Immediate Response
            let transform = '';
            let height = 140; /* Default Standing Height */

            // Note: Visual height change logic
            // In PUBG, C toggles, but here we track holding or simple state.
            // Prompt implies user PRESSES C as part of combo.
            if (isCrouching) {
                height = 90;
                transform += 'translateY(0px) '; // Visually lower
            }

            // Movement / Lean Logic
            const leanLeft = activeKeys.has('q');
            const leanRight = activeKeys.has('e');
            const moveLeft = activeKeys.has('a');
            const moveRight = activeKeys.has('d');

            let xOffset = 0;
            let rotate = 0;

            // Simple priority logic for visuals
            if (leanLeft) {
                xOffset = -70;
                rotate = -15;
            } else if (leanRight) {
                xOffset = 70;
                rotate = 15;
            } else if (moveLeft) {
                xOffset = -40;
            } else if (moveRight) {
                xOffset = 40;
            }

            if (rotate !== 0) {
                transform += `translateX(${xOffset}px) rotateZ(${rotate}deg) `;
            } else {
                transform += `translateX(${xOffset}px) `;
            }

            playerEl.style.height = height + 'px';
            playerEl.style.transform = transform;
        }

        // --- Input Handling ---
        // Map physical keys to logical actions
        const KEY_MAP = {
            'KeyQ': 'q',
            'KeyW': 'w',
            'KeyE': 'e',
            'KeyA': 'a',
            'KeyS': 's',
            'KeyD': 'd',
            'KeyC': 'c',
            'Space': ' ',
            'KeyF': 'f'
        };

        let pendingShot = null; // { type: 'EDC'|'QAC', fireTime: number, timer: number }

        window.addEventListener('keydown', (e) => {
            if (e.repeat) return;

            // Prevent scrolling for game keys
            if (KEY_MAP[e.code] || e.code === 'Space') {
                // Only prevent default if it's a game key to avoid blocking F12/Refresh etc if they clash, 
                // but Space definitely needs it.
                if (e.code === 'Space') e.preventDefault();
            }

            const code = e.code;
            let k = KEY_MAP[code];
            if (!k) return; // Ignore non-game keys

            // Fire Logic
            if (k === ' ' || k === 'f') {
                handleFire();
                activeKeys.add(' '); // Visual feedback
                setTimeout(() => activeKeys.delete(' '), 100);
                updateVisuals();
                return;
            }

            if (keyEls[k]) {
                activeKeys.add(k);
                const ts = now();
                inputLog.unshift({ key: k, time: ts, type: 'down' });
                if (inputLog.length > MAX_HISTORY) inputLog.pop();

                // State Updates
                if (k === 'c') {
                    // Toggle Crouch
                    isCrouching = !isCrouching;
                    lastStanceChangeTime = ts;
                }
                // if (k === 'a' || k === 'd') {
                //     isMoving = true;
                // }

                updateVisuals();
                checkForReturnSequence(k); // Check for return sequence on every keydown
            }
        });

        window.addEventListener('keyup', (e) => {
            const code = e.code;
            let k = KEY_MAP[code];
            if (!k) return;

            if (k === ' ' || k === 'f') {
                activeKeys.delete(' ');
                updateVisuals();
                return;
            }

            if (keyEls[k]) {
                activeKeys.delete(k);
                const ts = now();
                inputLog.unshift({ key: k, time: ts, type: 'up' });
                if (inputLog.length > MAX_HISTORY) inputLog.pop();

                // State Updates
                // Note: C is now Toggle, so we don't change state on keyup

                if (k === 'a' || k === 'd') {
                    // Check if other movement key is still held
                    const moving = activeKeys.has('a') || activeKeys.has('d');
                    isMoving = moving;
                    if (!moving) {
                        lastMovementReleaseTime = ts;
                    }
                }
                updateVisuals();
            }
        });

        window.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Left Click
                handleFire();
            }
        });

        // --- Core Logic ---

        function handleFire() {
            if (pendingShot) return; // Prevent double firing overlap logic

            const fireTime = now();

            // Capture state
            const stateSnapshot = {
                fireTime: fireTime,
                isCrouching: isCrouching,
                isMoving: isMoving,
                lastStop: lastMovementReleaseTime,
                lastStanceChange: lastStanceChangeTime,
                recentInputs: inputLog.slice(0, 20).map(i => ({ ...i })),
            };

            const preCheck = checkPreFireConditions(stateSnapshot);

            // Immediate Check (Simulated Delay comes later if successful)
            // Actually, we must delay the JUDGEMENT, but we can verify logic now.
            // If we delay logic, we can't track "future" inputs for post-fire easily without complex async.
            // Approach: 
            // 1. Validate Pre-Fire State immediately.
            // 2. If invalid -> Schedule Fail Feedback (delayed).
            // 3. If valid -> Start "Wait for Return" mode.
            // 4. In KeyDown, if Return completes -> Schedule Success Feedback (delayed from completion time).

            // DEFERRED FEEDBACK LOGIC
            // If invalid but TYPE is known (e.g. Too Fast/Slow), we wait for return.
            // If invalid and NO TYPE (e.g. just random clicking), fail immediately.

            if (!preCheck.valid && !preCheck.type) {
                setTimeout(() => {
                    showFeedback(false, preCheck.msg, preCheck.debug);
                }, serverDelay);
                return;
            }

            // Valid OR Invalid-but-typed (Deferred)
            // If preCheck.type is QAC (e.g. started with QAC), return target is EDC.
            const targetType = (preCheck.type === 'EDC') ? 'QAC' : 'EDC';

            pendingShot = {
                type: targetType,
                fireTime: fireTime,
                result: preCheck, // Store the judgement result
                timer: setTimeout(() => {
                    // Time expired waiting for return
                    // If the original result was valid, this is a failure (Return Missing).
                    // If original was invalid, show that failure.
                    if (preCheck.valid) {
                        showFeedback(false, "콤보 실패: 복귀 입력 늦음/누락", "Missing " + targetType + " after Fire");
                    } else {
                        showFeedback(false, preCheck.msg, preCheck.debug); // Show the deferred failure
                    }
                    pendingShot = null;
                }, 1200 + serverDelay) // 1.2s timeout inclusive of delay
            };

            // We mimic "Server Logic" by just holding this state. 
            // Real inputs will clear it.
        }

        // Check if Pre-Fire execution (EDC->Fire) was good
        function checkPreFireConditions(state) {
            const T_FIRE = state.fireTime;

            // 1. Pattern Detection (First Priority)
            // Find Stand-Up (C Down)
            const cIdx = state.recentInputs.findIndex(i => i.key === 'c' && i.type === 'down' && i.time <= T_FIRE);
            if (cIdx === -1) return { valid: false, msg: "C 입력 없음", debug: "No C found" }; // Immediate Fail

            // Find Move
            let mIdx = -1, mKey = '';
            for (let i = cIdx + 1; i < state.recentInputs.length; i++) {
                if (state.recentInputs[i].type === 'down' && ['a', 'd'].includes(state.recentInputs[i].key)) {
                    mIdx = i; mKey = state.recentInputs[i].key; break;
                }
            }
            if (mIdx === -1) return { valid: false, msg: "이동 입력 누락", debug: "No A/D before C" };

            // Find Peek
            let pIdx = -1, pKey = '';
            const expectedPeek = (mKey === 'a') ? 'q' : 'e';
            for (let i = mIdx + 1; i < state.recentInputs.length; i++) {
                if (state.recentInputs[i].type === 'down' && ['q', 'e'].includes(state.recentInputs[i].key)) {
                    pIdx = i; pKey = state.recentInputs[i].key; break;
                }
            }
            if (pIdx === -1) return { valid: false, msg: "피킹 입력 누락", debug: "No Q/E before Move" };

            // Determine Type
            const type = (expectedPeek === 'q') ? 'QAC' : 'EDC';

            // 2. Logic Validation (Deferred Fail Checks)

            // Combination Check
            if (pKey !== expectedPeek) {
                return { valid: false, type: type, msg: "조합 오류", debug: `${pKey}+${mKey}` };
            }

            // Move Check
            // if (state.isMoving) {
            //     return { valid: false, type: type, msg: "이동 중 발사", debug: "Moving" };
            // }

            // Timing Check
            const timeSinceStanceChange = T_FIRE - state.lastStanceChange;
            const delta = Math.round(timeSinceStanceChange);

            if (delta < 90) {
                return {
                    valid: false,
                    type: type,
                    msg: `C 이후 발사 타이밍이 서버 도달 전`,
                    debug: `Too Fast (${delta}ms) < 90ms`
                };
            }

            if (delta > maxHitWindow) {
                return {
                    valid: false,
                    type: type,
                    msg: `히트박스 이득 소멸`,
                    debug: `Too Slow (${delta}ms) > ${maxHitWindow}ms`
                };
            }

            // Input Interval Check
            const cEvent = state.recentInputs[cIdx];
            const mEvent = state.recentInputs[mIdx];
            const pEvent = state.recentInputs[pIdx];

            console.log("state.recentInputs")
            console.log(state.recentInputs)

            console.log("event")
            console.log(cEvent)
            console.log(mEvent)
            console.log(pEvent)

            const d1 = mEvent.time - pEvent.time;
            const d2 = cEvent.time - mEvent.time;

            if (d1 < PEEK_CONFIG.MIN_INTERVAL || d2 < PEEK_CONFIG.MIN_INTERVAL)
                return { valid: false, type: type, msg: "입력 너무 빠름", debug: `Intervals: ${Math.round(d1)}, ${Math.round(d2)}` };

            // Success
            return {
                valid: true,
                type: type,
                debug: `PERFECT TIMING (${delta}ms)\nServer Hit Frame`
            };
        }

        function checkForReturnSequence(key) {
            if (!pendingShot) return;

            // Strict Sequence Check for Return
            // Target: EDC -> E, D, C (in that order)
            // We check the last 3 'down' events since fire.

            // Get inputs since fire
            const recent = inputLog.filter(i => i.time > pendingShot.fireTime && i.type === 'down');

            // If we have fewer than 3 inputs, we can't have completed EDC yet.
            if (recent.length < 3) return;

            // `recent` array is ordered Newest to Oldest (index 0 is newest).
            // We want [Oldest, Middle, Newest] to be [E, D, C].

            const lastKey = recent[0];  // Newest (should be C)
            const prevKey = recent[1];  // Middle (should be D)
            const firstKey = recent[2]; // Oldest (should be E)

            // 1. Trigger Check: Must be the 'c' key press that finishes it.
            if (key !== 'c') return;
            if (lastKey.key !== 'c') return; // Double check history

            let matched = false;

            if (pendingShot.type === 'EDC') {
                // Expect E -> D -> C
                if (firstKey.key === 'e' && prevKey.key === 'd' && lastKey.key === 'c') matched = true;
            } else {
                // Expect Q -> A -> C (if hypothetical Right Peek started)
                if (firstKey.key === 'q' && prevKey.key === 'a' && lastKey.key === 'c') matched = true;
            }

            if (matched) {
                // Success (or Resolved Failure)
                clearTimeout(pendingShot.timer);

                const delayWait = serverDelay;

                // Use stored result
                const isSuccess = pendingShot.result.valid;
                const msg = pendingShot.result.msg || "서버 판정 프레임 명중 (90~120ms)";
                const debug = pendingShot.result.debug + `\nReturn: ${pendingShot.type} OK`;

                setTimeout(() => {
                    showFeedback(isSuccess, msg, debug);
                }, delayWait);

                pendingShot = null;
            }
        }

        let feedbackTimer = null;

        function showFeedback(isSuccess, msg, debugInfo = "") {
            // Stats
            if (isSuccess) stats.success++;
            else stats.fail++;

            successCountEl.innerText = stats.success;
            failCountEl.innerText = stats.fail;

            // UI
            feedbackEl.innerText = msg;
            feedbackEl.className = isSuccess ? 'msg-success' : 'msg-fail';

            // Log
            actionLogEl.innerHTML = `<div class="log-entry ${isSuccess ? 'ok' : 'error'}">` +
                `<div>${msg}</div><div class="debug-info">${debugInfo}</div></div>` +
                actionLogEl.innerHTML.slice(0, 1000); // Truncate history

            // Visual Tint
            playerEl.style.backgroundColor = isSuccess
                ? getComputedStyle(document.documentElement).getPropertyValue('--success-color')
                : getComputedStyle(document.documentElement).getPropertyValue('--fail-color');

            if (feedbackTimer) clearTimeout(feedbackTimer);

            feedbackTimer = setTimeout(() => {
                playerEl.style.backgroundColor = ""; // Reset
                feedbackTimer = null;
            }, 1500);
        }

        // Initialize Visuals
        updateVisuals();
    </script>
</body>

</html>
